
# -*- coding: utf-8 -*-
"""Untitled0.ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/16XjkqjVIxo-aFqbwBef9Q2jxFrfh72wf
"""
#outliers filtered out for each separate window of data
import numpy as np
from scipy.optimize import fsolve
import matplotlib
import matplotlib.pyplot as plt
matplotlib.use('Agg')
from mpl_toolkits.mplot3d import Axes3D
import math



import RPi.GPIO as GPIO
import time
import math
import numpy as np
#import astropy
# Setup GPIO
GPIO.setmode(GPIO.BCM)
# Define servo GPIO pins
SERVO_X_PIN = 18  # Horizontal servo
SERVO_Y_PIN = 17  # Vertical servo
LASER_PIN = 25     # Laser control pin
# Setup PWM for servos
GPIO.setup(SERVO_X_PIN, GPIO.OUT)
GPIO.setup(SERVO_Y_PIN, GPIO.OUT)
GPIO.setup(LASER_PIN, GPIO.OUT)
servo_x = GPIO.PWM(SERVO_X_PIN, 50)  # 50 Hz frequency
servo_y = GPIO.PWM(SERVO_Y_PIN, 50)  # 50 Hz frequency
servo_x.start(0)
servo_y.start(0)


current_horizontal_angle = 0
current_vertical_angle = 0
def angle_to_duty_cycle(angle):
    duty_cycle = 2 + (angle+90)*10/180  # Adjust based on your servo's range
    return max(2, min(12, duty_cycle))  # Ensure duty cycle is within range
# Function to turn the laser on
def turn_laser_on():
    GPIO.output(LASER_PIN, GPIO.HIGH)  # Turn on the laser
    print("Laser ON")


def cartesian_to_servo_angles(x, y, z):
    """
    Compute servo angles from target coordinates.
    
    Assumptions:
      - The laser is mounted at height H0 (default 1 unit).
      - The target is on the ground (z=0 for the hit point).
      - The input (x, y, z) uses:
            x: rightward steps (positive = right)
            y: forward steps (positive = forward)
            z: vertical step input (used here only to set baseline if needed)
    
    With this mapping:
      - The horizontal servo angle (in degrees) is defined by:
             H = -atan2(x, y)
      - The elevation angle E (from the horizontal) needed to hit the ground is:
             E = arctan(H0 / y)
        and the servo’s vertical angle is defined as:
             V = -(90 - E)
    
    For example:
      (1, 1, -1) -> horizontal: -45°, vertical: -45°
      (1, 2, -1) -> horizontal: -atan2(1,2) ≈ -26.565°, vertical: -(90 - arctan(1/2)) ≈ -63.435°
    
    This means the beam for (1,2,-1) hits the ground twice as far forward as for (1,1,-1).
    """
    # Horizontal servo angle: based on x and y.
    horizontal_angle = -(math.degrees(math.atan2(x,y)) - 180) - 180
    
    
    p = math.sqrt(x**2 + y**2)
    vertical_angle = -90 - math.degrees(math.atan(z/p))

    
    return horizontal_angle, vertical_angle

#cartesian_coords = (1,1,-1)  # Example coordinates
target_horizontal_angle, target_vertical_angle = cartesian_to_servo_angles(83, 340.4, -233.7)
print("Target Horizontal Angle:", target_horizontal_angle)  # Should print 0°
print("Target Vertical Angle:", target_vertical_angle) 
target_vertical_angle = target_vertical_angle + 7
target_horizontal_angle = target_horizontal_angle - 20

try:
    # Turn the laser on
    turn_laser_on()
    GPIO.output(LASER_PIN, GPIO.HIGH)
    time.sleep(1)
#    GPIO.output(LASER_PIN, GPIO.LOW)
    while True:
        print(target_vertical_angle)
        print( " is target vertical angle")

        print("new target vertical angle")
        print(target_vertical_angle)
        #target_horizontal_angle = 90
        #target_vertical_angle = 90
        print("target horiz angle: ")
        print(target_horizontal_angle)
        print("current horiz angle: ")
        print(current_horizontal_angle)

        step_size = 1  # Degrees to move per iteration
        if current_horizontal_angle < target_horizontal_angle:
           current_horizontal_angle = min(current_horizontal_angle + step_size, target_horizontal_angle)
        elif current_horizontal_angle > target_horizontal_angle:
           current_horizontal_angle = max(current_horizontal_angle - step_size, target_horizontal_angle)
        
        duty_cycle_x = angle_to_duty_cycle(current_horizontal_angle) #this was originally current_horizontal_angle
        
        servo_x.ChangeDutyCycle(duty_cycle_x)
        
        print("in horizontal loop")
        print("--------------------")
        
        time.sleep(0.1)
        
        if (abs((current_horizontal_angle - target_horizontal_angle)) < .1):
           break
except KeyboardInterrupt:
        print("Program terminated.")
time.sleep(1)
servo_x.stop()
try:
    while True: #vertical angle
        print("target vert angle: ")
        print(target_vertical_angle)
        print("current vert angle: ")
        print(current_vertical_angle)
        if current_vertical_angle < target_vertical_angle:
            current_vertical_angle = min(current_vertical_angle + step_size, target_vertical_angle)
        elif current_vertical_angle > target_vertical_angle:
            current_vertical_angle = max(current_vertical_angle - step_size, target_vertical_angle)
        duty_cycle_y = angle_to_duty_cycle(current_vertical_angle)
        servo_y.ChangeDutyCycle(duty_cycle_y)
        print("in vertical loop")
        print("------------------")
        time.sleep(0.1)
        if ((abs(current_vertical_angle - target_vertical_angle)) < .1):
           break
except KeyboardInterrupt:
    print("Program terminated.")

finally:
    servo_x.stop()
    servo_y.stop()
    print("laser stay on")
    time.sleep(300) #make laser stay on
    GPIO.output(LASER_PIN, GPIO.LOW)
    GPIO.cleanup()  # Clean up GPIO settings!



